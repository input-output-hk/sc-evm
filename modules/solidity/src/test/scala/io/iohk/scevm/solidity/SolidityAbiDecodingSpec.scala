package io.iohk.scevm.solidity

import io.iohk.bytes.ByteString
import io.iohk.ethereum.utils.Hex
import io.iohk.scevm.domain.UInt256
import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec
import org.scalatestplus.scalacheck.ScalaCheckPropertyChecks

class SolidityAbiDecodingSpec extends AnyWordSpec with ScalaCheckPropertyChecks with Matchers {
  "Solidity ABI decoders" should {

    // a few examples are taken from https://docs.soliditylang.org/en/develop/abi-spec.html#examples

    "decode an uint256" in {
      val bytes =
        ByteString(Hex.decodeAsArrayUnsafe("0000000000000000000000000000000000000000000000000000000000000045"))

      SolidityAbiDecoder[UInt256].decode(bytes) shouldBe 69
    }

    "decode a single tuple" in {
      val bytes = ByteString(
        Hex.decodeAsArrayUnsafe(
          "000000000000000000000000000000000000000000000000000000000000000a" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "000000000000000000000000000000000000000000000000000000000000000a" +
            "3078373436353733373400000000000000000000000000000000000000000000"
        )
      )
      val expected = (10, "0x74657374")

      SolidityAbiDecoder[(UInt256, String)].decode(bytes) shouldBe expected
    }

    "decode a dynamic seq of tuples with one element" in {
      val bytes = ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000001" +
            "0000000000000000000000000000000000000000000000000000000000000020" +
            "000000000000000000000000000000000000000000000000000000000000000a" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "000000000000000000000000000000000000000000000000000000000000000a" +
            "3078373436353733373400000000000000000000000000000000000000000000"
        )
      )
      val expected = Seq((10, "0x74657374"))

      SolidityAbiDecoder[Seq[(UInt256, String)]].decode(bytes) shouldBe expected
    }

    "decode a dynamic seq of tuples with 3 elements" in {
      val bytes = ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000003" +
            "0000000000000000000000000000000000000000000000000000000000000060" +
            "00000000000000000000000000000000000000000000000000000000000000e0" +
            "0000000000000000000000000000000000000000000000000000000000000160" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "0000000000000000000000000000000000000000000000000000000000000006" +
            "666f6f6261720000000000000000000000000000000000000000000000000000" +
            "0000000000000000000000000000000000000000000000000000000000000010" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "0000000000000000000000000000000000000000000000000000000000000006" +
            "666f6f6261720000000000000000000000000000000000000000000000000000" +
            "0000000000000000000000000000000000000000000000000000000000000100" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "0000000000000000000000000000000000000000000000000000000000000006" +
            "666f6f6261720000000000000000000000000000000000000000000000000000"
        )
      )
      val expected = Seq((64, "foobar"), (16, "foobar"), (256, "foobar"))

      SolidityAbiDecoder[Seq[(UInt256, String)]].decode(bytes) shouldBe expected
    }

    "decode a tuple3" in {
      val bytes = ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000060" +
            "0000000000000000000000000000000000000000000000000000000000000001" +
            "00000000000000000000000000000000000000000000000000000000000000a0" +
            "0000000000000000000000000000000000000000000000000000000000000004" +
            "6461766500000000000000000000000000000000000000000000000000000000" +
            "0000000000000000000000000000000000000000000000000000000000000003" +
            "0000000000000000000000000000000000000000000000000000000000000001" +
            "0000000000000000000000000000000000000000000000000000000000000002" +
            "0000000000000000000000000000000000000000000000000000000000000003"
        )
      )

      val expected = ("dave", UInt256(1), Seq[UInt256](1, 2, 3))
      SolidityAbiDecoder[(String, UInt256, Seq[UInt256])].decode(bytes) shouldBe expected
    }
  }
}
