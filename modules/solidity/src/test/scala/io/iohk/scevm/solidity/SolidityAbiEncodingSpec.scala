package io.iohk.scevm.solidity

import io.iohk.bytes.ByteString
import io.iohk.ethereum.utils.Hex
import io.iohk.scevm.domain.UInt256
import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec
import org.scalatestplus.scalacheck.ScalaCheckPropertyChecks

import SolidityAbiEncodingSpec._

class SolidityAbiEncodingSpec extends AnyWordSpec with ScalaCheckPropertyChecks with Matchers {

  "Solidity ABI encoders" should {

    // a few examples are taken from https://docs.soliditylang.org/en/develop/abi-spec.html#examples

    "encode a uint256" in {
      val expected =
        ByteString(Hex.decodeAsArrayUnsafe("0000000000000000000000000000000000000000000000000000000000000045"))

      SolidityAbiEncoder[UInt256].encode(69) shouldBe expected
    }

    "encode fixed size tuple1" in {
      SolidityAbiEncoder[Tuple1[UInt256]].encode(Tuple1(16)) shouldBe ByteString(
        Hex.decodeAsArrayUnsafe("0000000000000000000000000000000000000000000000000000000000000010")
      )
    }

    "encode a dynamic tuple1" in {
      SolidityAbiEncoder[Tuple1[String]].encode(Tuple1("foo")) shouldBe ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000020" +   // offset
            "0000000000000000000000000000000000000000000000000000000000000003" + // string size
            "666f6f0000000000000000000000000000000000000000000000000000000000"   // "foo"
        )
      )
    }

    "encode fixed size tuple2" in {
      SolidityAbiEncoder[(UInt256, UInt256)].encode((1, 2)) shouldBe ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000001" +
            "0000000000000000000000000000000000000000000000000000000000000002"
        )
      )
    }

    "encode dynamic size tuple2" in {
      SolidityAbiEncoder[(String, UInt256)].encode(("foo", 2)) shouldBe ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000040" +   // offset for string foo
            "0000000000000000000000000000000000000000000000000000000000000002" + // 2
            "0000000000000000000000000000000000000000000000000000000000000003" + // string size
            "666f6f0000000000000000000000000000000000000000000000000000000000"   // "foo"
        )
      )

      SolidityAbiEncoder[(UInt256, String)].encode((2, "foo")) shouldBe ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000002" +   // 2
            "0000000000000000000000000000000000000000000000000000000000000040" + // offset for string foo
            "0000000000000000000000000000000000000000000000000000000000000003" + // string size
            "666f6f0000000000000000000000000000000000000000000000000000000000"   // "foo"
        )
      )
    }

    "encode fixed size tuple3" in {
      SolidityAbiEncoder[(UInt256, UInt256, UInt256)].encode((1, 2, 3)) shouldBe ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000001" +
            "0000000000000000000000000000000000000000000000000000000000000002" +
            "0000000000000000000000000000000000000000000000000000000000000003"
        )
      )
    }

    "encode dynamic size tuple3" in {
      SolidityAbiEncoder[(String, UInt256, String)].encode(("foo", 2, "bar")) shouldBe ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000060" +   // offset for string foo
            "0000000000000000000000000000000000000000000000000000000000000002" + // 2
            "00000000000000000000000000000000000000000000000000000000000000a0" + // offset for string bar
            "0000000000000000000000000000000000000000000000000000000000000003" + // string size
            "666f6f0000000000000000000000000000000000000000000000000000000000" + // "foo"
            "0000000000000000000000000000000000000000000000000000000000000003" + // string size
            "6261720000000000000000000000000000000000000000000000000000000000"   // "bar"
        )
      )
    }

    "encode derive encoders for case class" in {
      implicit val enc: SolidityAbiEncoder[TestDynamicCaseClass] =
        SolidityAbiEncoder.to(TestDynamicCaseClass.unapply(_).get)

      SolidityAbiEncoder[TestDynamicCaseClass].encode(TestDynamicCaseClass("foo", 2)) shouldBe ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000040" +   // offset for string foo
            "0000000000000000000000000000000000000000000000000000000000000002" + // 2
            "0000000000000000000000000000000000000000000000000000000000000003" + // string size
            "666f6f0000000000000000000000000000000000000000000000000000000000"   // "foo"
        )
      )
    }

    "encode derive encoders for more complex case classes" in {
      implicit val enc: SolidityAbiEncoder[TestDynamicCaseClass] =
        SolidityAbiEncoder.to(TestDynamicCaseClass.unapply(_).get)
      implicit val enc2: SolidityAbiEncoder[TestComplexCaseClass] =
        SolidityAbiEncoder.to(TestComplexCaseClass.unapply(_).get)

      SolidityAbiEncoder[TestComplexCaseClass].encode(
        TestComplexCaseClass("bar", TestDynamicCaseClass("foo", 2))
      ) shouldBe ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000040" +   // offset for string "bar"
            "0000000000000000000000000000000000000000000000000000000000000080" + // offset for tuple TestDynamicCaseClass
            "0000000000000000000000000000000000000000000000000000000000000003" + // string size
            "6261720000000000000000000000000000000000000000000000000000000000" + // "bar"
            "0000000000000000000000000000000000000000000000000000000000000040" + // offset for string foo
            "0000000000000000000000000000000000000000000000000000000000000002" + // 2
            "0000000000000000000000000000000000000000000000000000000000000003" + // string size
            "666f6f0000000000000000000000000000000000000000000000000000000000"   // "foo"
        )
      )
    }

    "encode a dynamic seq of tuples with 3 elements" in {
      val expectedBytes = ByteString(
        Hex.decodeAsArrayUnsafe(
          "0000000000000000000000000000000000000000000000000000000000000003" +
            "0000000000000000000000000000000000000000000000000000000000000060" +
            "00000000000000000000000000000000000000000000000000000000000000e0" +
            "0000000000000000000000000000000000000000000000000000000000000160" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "0000000000000000000000000000000000000000000000000000000000000006" +
            "666f6f6261720000000000000000000000000000000000000000000000000000" +
            "0000000000000000000000000000000000000000000000000000000000000010" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "0000000000000000000000000000000000000000000000000000000000000006" +
            "666f6f6261720000000000000000000000000000000000000000000000000000" +
            "0000000000000000000000000000000000000000000000000000000000000100" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "0000000000000000000000000000000000000000000000000000000000000006" +
            "666f6f6261720000000000000000000000000000000000000000000000000000"
        )
      )
      val data = Seq((64, "foobar"), (16, "foobar"), (256, "foobar")).map { case (a, b) => (UInt256(a), b) }

      SolidityAbiEncoder[Seq[(UInt256, String)]].encode(data) shouldBe expectedBytes
    }

    "encode multiple nested lists" in {
      val expectedBytes = Hex.decodeUnsafe(
        "0000000000000000000000000000000000000000000000000000000000000040" +
          "0000000000000000000000000000000000000000000000000000000000000140" +
          "0000000000000000000000000000000000000000000000000000000000000002" + // - count for [[1, 2], [3]]
          "0000000000000000000000000000000000000000000000000000000000000040" + // - offset of [1, 2]
          "00000000000000000000000000000000000000000000000000000000000000a0" + // - offset of [3]
          "0000000000000000000000000000000000000000000000000000000000000002" + // - count for [1, 2]
          "0000000000000000000000000000000000000000000000000000000000000001" + // - encoding of 1
          "0000000000000000000000000000000000000000000000000000000000000002" + // - encoding of 2
          "0000000000000000000000000000000000000000000000000000000000000001" + // - count for [3]
          "0000000000000000000000000000000000000000000000000000000000000003" + // - encoding of 3
          "0000000000000000000000000000000000000000000000000000000000000003" + // - count for ["one", "two", "three"]
          "0000000000000000000000000000000000000000000000000000000000000060" + // - offset for "one"
          "00000000000000000000000000000000000000000000000000000000000000a0" + // - offset for "two"
          "00000000000000000000000000000000000000000000000000000000000000e0" + // - offset for "three"
          "0000000000000000000000000000000000000000000000000000000000000003" + // - count for "one"
          "6f6e650000000000000000000000000000000000000000000000000000000000" + // - encoding of "one"
          "0000000000000000000000000000000000000000000000000000000000000003" + // - count for "two"
          "74776f0000000000000000000000000000000000000000000000000000000000" + // - encoding of "two"
          "0000000000000000000000000000000000000000000000000000000000000005" + // - count for "three"
          "7468726565000000000000000000000000000000000000000000000000000000"   // - encoding of "three"
      )
      val data = (Seq(Seq(UInt256(1), UInt256(2)), Seq(UInt256(3))), Seq("one", "two", "three"))
      SolidityAbiEncoder[(Seq[Seq[UInt256]], Seq[String])].encode(data) shouldBe expectedBytes
    }
  }

}

object SolidityAbiEncodingSpec {

  final case class TestDynamicCaseClass(foo: String, bar: UInt256)
  final case class TestComplexCaseClass(foo: String, bar: TestDynamicCaseClass)
}
